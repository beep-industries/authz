<?xml version="1.0" encoding="UTF-8"?>
<implementation_specification>
  <overview>
    Implement comprehensive support for Role management and Permission Overrides in a Rust-based authorization system using AuthZed (SpiceDB).
    The implementation must follow the established architectural patterns in the project and handle all role-related and permission override events from the Communities service.

    KEY REQUIREMENTS:
    - Translate role permission bitmasks to AuthZed server relations (e.g., message_sender, channel_viewer)
    - Permission overrides are ONLY for channel-level permissions (not server or role level)
    - Each permission bit creates a separate server relation relationship
    - Role deletion does NOT cascade delete member assignments (handled separately)
    - Permission overrides are independent objects that can be deleted by override_id
    - Follow existing test patterns (unit tests with mock repositories)
  </overview>

  <architectural_context>
    <layer name="handlers" location="listeners/src/rabbit/role/handler.rs and listeners/src/rabbit/permission_override/handler.rs">
      <responsibilities>
        - Receive protobuf events from RabbitMQ message queues
        - Validate and log incoming events with structured tracing
        - Transform protobuf messages into domain entities
        - Delegate to service layer for business logic
        - Return Result&lt;(), Infallible&gt; (errors are logged, not propagated to prevent message requeue)
      </responsibilities>
      <pattern>
        - Functions are async and instrumented with #[instrument(skip(state), fields(...))]
        - Take Arc&lt;AppState&gt; and protobuf message as parameters
        - Use info! for success, error! for failures with error context
        - Clone state before passing to service layer
        - Never panic, always log and return Ok(())
      </pattern>
      <example>
        See: listeners/src/rabbit/server/handler.rs and listeners/src/rabbit/channel/handler.rs
      </example>
    </layer>

    <layer name="services" location="core/src/domain/role/service.rs and core/src/domain/permission_override/service.rs">
      <responsibilities>
        - Implement business logic and domain rules
        - Orchestrate repository operations
        - Handle error transformation from repository to domain errors
        - Provide instrumented logging at domain level
      </responsibilities>
      <pattern>
        - Implement trait methods defined in port.rs
        - Use generic type parameters for repository dependencies
        - Log at info! level for operation start/success/failure
        - Transform repository errors into domain errors
        - Include comprehensive unit tests with mock repositories
      </pattern>
      <example>
        See: core/src/domain/server/service.rs and core/src/domain/channel/service.rs
      </example>
    </layer>

    <layer name="repositories" location="core/src/infrastructure/role/repository/authzed/mod.rs and core/src/infrastructure/permission_override/repository/authzed/mod.rs">
      <responsibilities>
        - Translate domain entities into AuthZed relationships
        - Execute AuthZed API calls (create_relationship, filtered_delete, bulk operations)
        - Handle AuthZed-specific error mapping to domain errors
      </responsibilities>
      <pattern>
        - Implement repository trait from domain/port.rs
        - Use From/Into traits to convert entities (in entities.rs)
        - Map AuthZed errors to domain errors with context
        - Instrument with tracing for debugging
      </pattern>
      <example>
        See: core/src/infrastructure/server/repository/authzed/mod.rs
      </example>
    </layer>

    <layer name="entities" location="core/src/domain/role/entities.rs and core/src/domain/permission_override/entities.rs">
      <responsibilities>
        - Define input/output DTOs for domain operations
        - Provide Clone and Debug derives for all structs
        - Keep entities simple and focused on data transfer
      </responsibilities>
      <example>
        See: core/src/domain/server/entities.rs
      </example>
    </layer>

    <layer name="ports" location="core/src/domain/role/port.rs and core/src/domain/permission_override/port.rs">
      <responsibilities>
        - Define trait interfaces for Repository and Service
        - Specify async method signatures returning impl Future
        - Ensure Send + Sync bounds for async compatibility
      </responsibilities>
      <example>
        See: core/src/domain/server/port.rs
      </example>
    </layer>
  </architectural_context>

  <permissions_system>
    <permission_translation_crate>
      <description>
        Use the permission-translation crate to manage permission bitmasks.
        Reference: listeners/src/permissions_translations.rs
      </description>
      <capabilities>
        - Administrator (0x1) -> server#administrator relation
        - ManageServer (0x2) -> server#server_manager relation
        - ManageRoles (0x4) -> server#role_manager relation
        - CreateInvitation (0x8) -> server#invitation_creator relation
        - ManageChannels (0x10) -> server#channel_manager relation
        - ManageWebhooks (0x20) -> server#webhook_manager relation
        - ViewChannels (0x40) -> server#channel_viewer relation
        - SendMessages (0x80) -> server#message_sender relation
        - ManageNicknames (0x100) -> server#nickname_manager relation
        - ChangeNickname (0x200) -> server#nickname_changer relation
        - ManageMessages (0x400) -> server#message_manager relation
        - AttachFiles (0x800) -> server#file_attacher relation
      </capabilities>
      <usage>
        - CapabilityDescriptor maps permission names to hex values
        - PermissionBitmask (from protobuf) contains uint64 bitmask
        - Multiple permissions can be combined with bitwise OR
        - Parse bitmask by checking each bit (value &amp; permission_bit != 0)
      </usage>
      <bitmask_to_relation_mapping>
        Create a mapping function that converts permission enum Display name to server relation name:
        - "admin" -> "administrator"
        - "manage" -> "server_manager"
        - "manage_role" -> "role_manager"
        - "create_invitation" -> "invitation_creator"
        - "manage_channels" -> "channel_manager"
        - "manage_webhooks" -> "webhook_manager"
        - "view_channel" -> "channel_viewer"
        - "send_message" -> "message_sender"
        - "manage_nicknames" -> "nickname_manager"
        - "change_nickname" -> "nickname_changer"
        - "manage_message" -> "message_manager"
        - "attach_files" -> "file_attacher"
      </bitmask_to_relation_mapping>
    </permission_translation_crate>

    <authzed_schema>
      <role_definition>
        - Relation: server (which server this role belongs to)
        - Relation: member (users assigned to this role)
        - Permission overrides: manage_role_grant/deny, view_role_grant/deny (NOT implemented in this phase)
        - Permissions: manage, view (derived from server permissions)
      </role_definition>

      <server_definition>
        - Has relations for each permission type pointing to role#member
        - Relations: administrator, server_manager, role_manager, invitation_creator, channel_manager, webhook_manager, channel_viewer, message_sender, nickname_manager, nickname_changer, message_manager, file_attacher
        - Owner has all permissions automatically (defined in schema)
      </server_definition>

      <channel_definition>
        - Relation: server (which server the channel belongs to)
        - Permission overrides: send_message_grant/deny, view_channel_grant/deny, manage_message_grant/deny, attach_files_grant/deny, manage_webhooks_grant/deny
        - Each override relation accepts: user | role#member
        - Permissions inherit from server, with channel-specific overrides taking precedence
      </channel_definition>
    </authzed_schema>
  </permissions_system>

  <events_to_implement>
    <event name="UpsertRole" proto_message="communities.events.UpsertRole">
      <fields>
        - role_id: string
        - server_id: string
        - permissions_bitmask: PermissionBitmask (uint64 value)
      </fields>
      <requirements>
        - Create/Update role entity in AuthZed
        - Create role->server relationship: role:role_id#server@server:server_id
        - Parse permissions_bitmask to identify ALL granted permissions
        - For EACH permission bit set, create: server:server_id#relation_name@role:role_id#member
        - Handle both creation (role doesn't exist) and update (role exists) scenarios
        - On update: DELETE all existing server permission relations for this role, then CREATE new ones
      </requirements>
      <authzed_relationships>
        BASE:
        - role:role_id#server@server:server_id

        FOR EACH PERMISSION BIT SET (example with bitmask 0x88 = SendMessages | CreateInvitation):
        - server:server_id#message_sender@role:role_id#member
        - server:server_id#invitation_creator@role:role_id#member
      </authzed_relationships>
      <implementation_steps>
        1. Parse permissions_bitmask using BeepPermissions descriptor
        2. Get list of permission names for all set bits
        3. Map each permission name to server relation name
        4. If update (role exists): delete all existing server#*@role:role_id#member relationships
        5. Create role#server relationship
        6. Create server#relation@role#member relationship for each permission
        7. Use bulk write operations if available for efficiency
      </implementation_steps>
    </event>

    <event name="DeleteRole" proto_message="communities.events.DeleteRole">
      <fields>
        - role_id: string
      </fields>
      <requirements>
        - Delete role entity and ALL relationships where role is resource
        - Use filtered_delete with resource_type="role" and optional_resource_id=role_id
        - This deletes: role#server, role#member relationships
        - Also delete ALL server permission relations where this role is subject: server#*@role:role_id#member
        - DO NOT delete member assignments separately (they are cascade deleted by AuthZed)
      </requirements>
      <authzed_operations>
        1. Delete all relationships where resource is role:role_id (handles role#server and role#member)
        2. Delete all relationships where subject is role:role_id#member (handles server#*@role relationships)
      </authzed_operations>
    </event>

    <event name="MemberAssignedToRole" proto_message="communities.events.MemberAssignedToRole">
      <fields>
        - user_id: string
        - role_id: string
      </fields>
      <requirements>
        - Create single role#member relationship
        - Relationship: role:role_id#member@user:user_id
        - This grants the user all permissions associated with the role
      </requirements>
      <authzed_relationships>
        - role:role_id#member@user:user_id
      </authzed_relationships>
    </event>

    <event name="MemberRemovedFromRole" proto_message="communities.events.MemberRemovedFromRole">
      <fields>
        - user_id: string
        - role_id: string
      </fields>
      <requirements>
        - Delete specific role#member relationship
        - Use filtered delete or direct relationship deletion
        - Target exact tuple: role:role_id#member@user:user_id
      </requirements>
      <authzed_operations>
        Delete relationship: role:role_id#member@user:user_id
      </authzed_operations>
    </event>

    <event name="UpsertPermissionOverride" proto_message="communities.events.UpsertPermissionOverride">
      <fields>
        - override_id: string (unique identifier for this override)
        - channel_id: string (target channel for override)
        - permission_bitmask: PermissionBitmask (which permissions to override)
        - action: OverrideAction (ALLOW=0 creates _grant, DENY=1 creates _deny)
        - target: OverrideTarget (oneof: user_id or role_id)
      </fields>
      <requirements>
        - Create channel permission override relationships for EACH permission in bitmask
        - Support both user and role targets
        - Handle ALLOW (create *_grant relation) and DENY (create *_deny relation)
        - Parse permission_bitmask to identify which permissions to override
        - ONLY supports channel-level permissions: send_message, view_channel, manage_message, attach_files, manage_webhooks
        - On update (same override_id): delete existing overrides then create new ones
        - Store override_id as relationship metadata or maintain mapping for deletion
      </requirements>
      <permission_to_channel_relation_mapping>
        - SendMessages (0x80) -> send_message_grant/send_message_deny
        - ViewChannels (0x40) -> view_channel_grant/view_channel_deny
        - ManageMessages (0x400) -> manage_message_grant/manage_message_deny
        - AttachFiles (0x800) -> attach_files_grant/attach_files_deny
        - ManageWebhooks (0x20) -> manage_webhooks_grant/manage_webhooks_deny

        OTHER PERMISSIONS (server-level) are IGNORED for channel overrides
      </permission_to_channel_relation_mapping>
      <authzed_relationships>
        FOR ALLOW action with user target (example: SendMessages permission):
        - channel:channel_id#send_message_grant@user:user_id

        FOR DENY action with user target:
        - channel:channel_id#send_message_deny@user:user_id

        FOR ALLOW action with role target:
        - channel:channel_id#send_message_grant@role:role_id#member

        FOR DENY action with role target:
        - channel:channel_id#send_message_deny@role:role_id#member

        MULTIPLE PERMISSIONS (example bitmask 0xC0 = SendMessages | ViewChannels, ALLOW, user target):
        - channel:channel_id#send_message_grant@user:user_id
        - channel:channel_id#view_channel_grant@user:user_id
      </authzed_relationships>
      <metadata_storage>
        Store override_id in relationship metadata/caveat for future deletion:
        - Option 1: Use AuthZed relationship optional_caveat to store override_id
        - Option 2: Maintain in-memory or database mapping of override_id -> list of relationships
        - Option 3: Include override_id in relationship subject/resource encoding (not recommended)

        RECOMMENDED: Use relationship metadata if supported, otherwise filtered delete by channel + target
      </metadata_storage>
    </event>

    <event name="DeletePermissionOverride" proto_message="communities.events.DeletePermissionOverride">
      <fields>
        - override_id: string
      </fields>
      <requirements>
        - Delete ALL permission override relationships associated with this override_id
        - Use stored metadata/mapping to identify which relationships to delete
        - If metadata approach: filter relationships by override_id in caveat
        - If no metadata: this becomes challenging - document limitation
      </requirements>
      <implementation_approaches>
        APPROACH 1 (with metadata):
        - Query relationships with override_id in metadata
        - Delete all matching relationships

        APPROACH 2 (without metadata - LIMITATION):
        - Cannot reliably delete without knowing channel_id, permission_bitmask, action, and target
        - Document that deletion requires maintaining a mapping service-side
        - Store mapping: override_id -> (channel_id, permission_bitmask, action, target)
        - On delete: lookup mapping, reconstruct relationships, delete them

        RECOMMENDED: Implement APPROACH 2 with in-memory or persistent mapping
      </implementation_approaches>
    </event>
  </events_to_implement>

  <domain_structure>
    <role_domain path="core/src/domain/role/">
      <files>
        <file name="mod.rs">
          <content>
            - Define RoleError enum using thiserror::Error
            - Error variants:
              * CreateRoleError { msg: String }
              * DeleteRoleError { msg: String }
              * AssignMemberError { msg: String }
              * RemoveMemberError { msg: String }
            - Export modules: pub mod entities, pub mod port, pub mod service
          </content>
        </file>

        <file name="entities.rs">
          <content>
            All structs with #[derive(Debug, Clone)]:

            - CreateRoleInput {
                role_id: String,
                server_id: String,
                permissions_bitmask: u64
              }

            - DeleteRoleInput {
                role_id: String
              }

            - AssignMemberInput {
                user_id: String,
                role_id: String
              }

            - RemoveMemberInput {
                user_id: String,
                role_id: String
              }
          </content>
        </file>

        <file name="port.rs">
          <content>
            - RoleRepository trait:
              * fn create(&amp;self, input: CreateRoleInput) -> impl Future&lt;Output = Result&lt;(), RoleError&gt;&gt;
              * fn delete(&amp;self, input: DeleteRoleInput) -> impl Future&lt;Output = Result&lt;(), RoleError&gt;&gt;
              * fn assign_member(&amp;self, input: AssignMemberInput) -> impl Future&lt;Output = Result&lt;(), RoleError&gt;&gt;
              * fn remove_member(&amp;self, input: RemoveMemberInput) -> impl Future&lt;Output = Result&lt;(), RoleError&gt;&gt;
              * Trait bounds: Send + Sync

            - RoleService trait:
              * Same methods as RoleRepository
              * Trait bounds: Send + Sync
          </content>
        </file>

        <file name="service.rs">
          <content>
            - Extend existing Service&lt;S, C&gt; to Service&lt;S, C, R&gt; where R: RoleRepository
            - Implement RoleService for Service&lt;S, C, R&gt;
            - Each method:
              * Log operation start with info!
              * Call repository method
              * Log success/failure with info!/error!
              * Return result

            - Include #[cfg(test)] mod tests with:
              * MockRoleRepository with Arc&lt;Mutex&gt; for state tracking
              * MockServerRepository and MockChannelRepository (stub implementations)
              * Test cases:
                - test_create_role_success
                - test_create_role_failure
                - test_delete_role_success
                - test_assign_member_success
                - test_assign_member_failure
                - test_remove_member_success
                - test_multiple_role_operations
              * Follow exact pattern from core/src/domain/server/service.rs tests
          </content>
        </file>
      </files>
    </role_domain>

    <permission_override_domain path="core/src/domain/permission_override/">
      <files>
        <file name="mod.rs">
          <content>
            - Define PermissionOverrideError enum using thiserror::Error
            - Error variants:
              * CreateOverrideError { msg: String }
              * DeleteOverrideError { msg: String }
            - Export modules: pub mod entities, pub mod port, pub mod service
          </content>
        </file>

        <file name="entities.rs">
          <content>
            All with #[derive(Debug, Clone)]:

            - OverrideTarget enum {
                User(String),
                Role(String)
              }

            - CreatePermissionOverrideInput {
                override_id: String,
                channel_id: String,
                permission_bitmask: u64,
                is_allow: bool,  // true = grant, false = deny
                target: OverrideTarget
              }

            - DeletePermissionOverrideInput {
                override_id: String,
                // Store metadata for deletion
                channel_id: String,
                permission_bitmask: u64,
                is_allow: bool,
                target: OverrideTarget
              }

            Note: DeletePermissionOverrideInput includes all fields to reconstruct relationships for deletion
          </content>
        </file>

        <file name="port.rs">
          <content>
            - PermissionOverrideRepository trait:
              * fn create(&amp;self, input: CreatePermissionOverrideInput) -> impl Future&lt;Output = Result&lt;(), PermissionOverrideError&gt;&gt;
              * fn delete(&amp;self, input: DeletePermissionOverrideInput) -> impl Future&lt;Output = Result&lt;(), PermissionOverrideError&gt;&gt;
              * Trait bounds: Send + Sync

            - PermissionOverrideService trait:
              * Same methods as PermissionOverrideRepository
              * Trait bounds: Send + Sync
          </content>
        </file>

        <file name="service.rs">
          <content>
            - Extend Service to Service&lt;S, C, R, P&gt; where P: PermissionOverrideRepository
            - Implement PermissionOverrideService for Service&lt;S, C, R, P&gt;
            - Include comprehensive tests following server service test patterns
          </content>
        </file>
      </files>
    </permission_override_domain>

    <common_service_update path="core/src/domain/common/service.rs">
      <content>
        Update Service struct from:
        pub struct Service&lt;S, C&gt; {
            pub server_repository: S,
            pub channel_repository: C,
        }

        To:
        pub struct Service&lt;S, C, R, P&gt; {
            pub server_repository: S,
            pub channel_repository: C,
            pub role_repository: R,
            pub permission_override_repository: P,
        }

        Update new() method and Clone implementation accordingly
      </content>
    </common_service_update>
  </domain_structure>

  <repository_implementation>
    <role_repository path="core/src/infrastructure/role/repository/authzed/">
      <file name="mod.rs">
        <content>
          - AuthzedRoleRepository struct {
              authzed_client: AuthZedClient,
              permissions_descriptor: Arc&lt;CapabilityDescriptor&gt;
            }

          - Implement RoleRepository trait:
            * create():
              1. Parse bitmask to get list of permissions
              2. Map permissions to server relation names
              3. Create Vec&lt;Relationship&gt; for all relationships
              4. Call authzed_client.bulk_write or multiple create_relationship calls
              5. Map errors to RoleError::CreateRoleError

            * delete():
              1. Create filter for role resource
              2. Create filter for server subjects with this role
              3. Call filtered_delete for both
              4. Map errors to RoleError::DeleteRoleError

            * assign_member():
              1. Convert to role#member relationship
              2. Call create_relationship
              3. Map errors to RoleError::AssignMemberError

            * remove_member():
              1. Create filter or direct delete for specific relationship
              2. Call delete operation
              3. Map errors to RoleError::RemoveMemberError
        </content>
      </file>

      <file name="entities.rs">
        <content>
          - Helper function: fn parse_permission_bitmask(bitmask: u64, descriptor: &amp;CapabilityDescriptor) -> Vec&lt;String&gt;
            * Iterate through all permissions in BeepPermissions::all_permissions()
            * Check if bit is set: bitmask &amp; permission.into() != 0
            * Collect permission Display names
            * Return list

          - Helper function: fn permission_to_server_relation(permission_name: &amp;str) -> &amp;str
            * Map permission Display name to server relation name
            * Use match statement with all mappings

          - Implement From&lt;CreateRoleInput&gt; for Vec&lt;Relationship&gt;
            * First relationship: role#server@server
            * Remaining relationships: server#relation@role#member for each permission

          - Implement From&lt;AssignMemberInput&gt; for Relationship
            * Create role#member@user relationship

          - Implement From&lt;DeleteRoleInput&gt; for RelationshipFilter
            * Filter for role resource_type with role_id

          - Implement From&lt;RemoveMemberInput&gt; for RelationshipFilter or Relationship
            * Target specific role#member@user tuple
        </content>
      </file>
    </role_repository>

    <permission_override_repository path="core/src/infrastructure/permission_override/repository/authzed/">
      <file name="mod.rs">
        <content>
          - AuthzedPermissionOverrideRepository struct {
              authzed_client: AuthZedClient,
              permissions_descriptor: Arc&lt;CapabilityDescriptor&gt;,
              override_mapping: Arc&lt;RwLock&lt;HashMap&lt;String, OverrideMetadata&gt;&gt;&gt;
            }

          - OverrideMetadata struct {
              channel_id: String,
              permission_bitmask: u64,
              is_allow: bool,
              target: OverrideTarget
            }

          - Implement PermissionOverrideRepository trait:
            * create():
              1. Parse permission_bitmask for CHANNEL permissions only
              2. Filter out non-channel permissions (warn if present)
              3. Map permissions to channel relation names (_grant or _deny)
              4. Create Vec&lt;Relationship&gt; for all overrides
              5. Store override_id -> metadata in mapping
              6. Call bulk_write
              7. Map errors

            * delete():
              1. Lookup override_id in mapping
              2. If not found, log warning and return Ok (idempotent)
              3. Reconstruct relationships from metadata
              4. Delete all relationships
              5. Remove from mapping
              6. Map errors
        </content>
      </file>

      <file name="entities.rs">
        <content>
          - Helper function: fn parse_channel_permissions(bitmask: u64, descriptor: &amp;CapabilityDescriptor) -> Vec&lt;String&gt;
            * Similar to parse_permission_bitmask but ONLY returns channel-applicable permissions
            * Channel permissions: SendMessages, ViewChannels, ManageMessages, AttachFiles, ManageWebhooks
            * Ignore/filter others

          - Helper function: fn permission_to_channel_relation(permission_name: &amp;str, is_allow: bool) -> Option&lt;String&gt;
            * Map permission to channel relation with _grant or _deny suffix
            * Return None for non-channel permissions

          - Implement From&lt;CreatePermissionOverrideInput&gt; for Vec&lt;Relationship&gt;
            * Parse bitmask for channel permissions
            * For each permission:
              - Get channel relation name
              - Create relationship with user or role#member subject based on target
              - Include override_id in metadata if possible
            * Return all relationships

          - Helper to reconstruct relationships from DeletePermissionOverrideInput
        </content>
      </file>
    </permission_override_repository>

    <override_mapping_storage path="core/src/infrastructure/permission_override/repository/">
      <file name="mapping.rs">
        <content>
          Optional persistent storage for override mappings:
          - Trait OverrideMappingStore {
              fn store(&amp;self, override_id: String, metadata: OverrideMetadata) -> Result&lt;(), Error&gt;
              fn get(&amp;self, override_id: &amp;str) -> Result&lt;Option&lt;OverrideMetadata&gt;, Error&gt;
              fn remove(&amp;self, override_id: &amp;str) -> Result&lt;(), Error&gt;
            }

          - InMemoryMappingStore (HashMap with RwLock) - default implementation
          - Optional: RedisMappingStore, DatabaseMappingStore for persistence
        </content>
      </file>
    </override_mapping_storage>
  </repository_implementation>

  <handler_implementation>
    <role_handlers path="listeners/src/rabbit/role/handler.rs">
      <functions>
        - pub async fn upsert_role(state: Arc&lt;AppState&gt;, input: UpsertRole) -> Result&lt;(), Infallible&gt;
          * Extract fields from input
          * Log processing start
          * Convert to CreateRoleInput { role_id, server_id, permissions_bitmask: input.permissions_bitmask.value }
          * Call state.service.create(input)
          * Log success or error
          * Return Ok(())

        - pub async fn delete_role(state: Arc&lt;AppState&gt;, input: DeleteRole) -> Result&lt;(), Infallible&gt;
          * Follow same pattern for DeleteRoleInput

        - pub async fn assign_member_to_role(state: Arc&lt;AppState&gt;, input: MemberAssignedToRole) -> Result&lt;(), Infallible&gt;
          * Convert to AssignMemberInput
          * Call state.service.assign_member(input)

        - pub async fn remove_member_from_role(state: Arc&lt;AppState&gt;, input: MemberRemovedFromRole) -> Result&lt;(), Infallible&gt;
          * Convert to RemoveMemberInput
          * Call state.service.remove_member(input)
      </functions>
      <pattern>
        Follow EXACT pattern from listeners/src/rabbit/server/handler.rs:
        - #[instrument(skip(state), fields(role_id = %input.role_id, ...))]
        - info! for "Processing ... request"
        - match on service result
        - info! for "Successfully ..."
        - error! for "Failed to ..." with error = ?e
        - Always return Ok(())
      </pattern>
    </role_handlers>

    <permission_override_handlers path="listeners/src/rabbit/permission_override/handler.rs">
      <functions>
        - pub async fn upsert_permission_override(state: Arc&lt;AppState&gt;, input: UpsertPermissionOverride) -> Result&lt;(), Infallible&gt;
          * Extract override_id, channel_id, permission_bitmask.value
          * Determine is_allow from action (ALLOW=0 -> true, DENY=1 -> false)
          * Extract target from oneof (user_id or role_id)
          * Create OverrideTarget enum
          * Convert to CreatePermissionOverrideInput
          * Call state.service.create(input)
          * Log and return

        - pub async fn delete_permission_override(state: Arc&lt;AppState&gt;, input: DeletePermissionOverride) -> Result&lt;(), Infallible&gt;
          * CHALLENGE: only have override_id
          * Need to lookup metadata from repository mapping
          * Create DeletePermissionOverrideInput with looked-up metadata
          * Call state.service.delete(input)
          * Note: If mapping not found, log warning but return Ok (idempotent delete)
      </functions>
      <special_handling>
        For delete_permission_override, the handler needs access to the override mapping.
        Consider:
        1. Pass repository directly to handler for lookup, OR
        2. Add a query method to service: fn get_override_metadata(&amp;self, override_id: &amp;str)
        3. Make delete service method take just override_id and handle lookup internally (RECOMMENDED)

        RECOMMENDED: Change DeletePermissionOverrideInput to just { override_id: String }
        and handle metadata lookup inside repository delete() method.
      </special_handling>
    </permission_override_handlers>

    <handler_registration path="listeners/src/rabbit/consumers/mod.rs or similar">
      <content>
        Register new handlers in RabbitMQ routing:
        - Map "communities.events.UpsertRole" to role::handler::upsert_role
        - Map "communities.events.DeleteRole" to role::handler::delete_role
        - Map "communities.events.MemberAssignedToRole" to role::handler::assign_member_to_role
        - Map "communities.events.MemberRemovedFromRole" to role::handler::remove_member_from_role
        - Map "communities.events.UpsertPermissionOverride" to permission_override::handler::upsert_permission_override
        - Map "communities.events.DeletePermissionOverride" to permission_override::handler::delete_permission_override
      </content>
    </handler_registration>
  </handler_implementation>

  <testing_requirements>
    <unit_tests>
      <service_tests>
        Follow EXACT pattern from core/src/domain/server/service.rs#tests:

        - Create MockRoleRepository with:
          * Arc&lt;Mutex&lt;bool&gt;&gt; should_fail
          * Arc&lt;Mutex&lt;String&gt;&gt; error_message
          * Arc&lt;Mutex&lt;usize&gt;&gt; call_count
          * Arc&lt;Mutex&lt;Option&lt;CreateRoleInput&gt;&gt;&gt; last_input
          * Methods: new(), with_failure(), get_call_count(), get_last_input()

        - Test cases for RoleService:
          * test_create_role_success - verify call count and input propagation
          * test_create_role_failure - verify error propagation
          * test_create_role_with_different_inputs - verify input handling
          * test_create_role_propagates_error - verify error message
          * test_create_role_multiple_calls - verify state tracking
          * test_delete_role_success
          * test_assign_member_success
          * test_assign_member_failure
          * test_remove_member_success
          * test_multiple_role_operations

        - Similar tests for PermissionOverrideService

        - Mock other repositories (ServerRepository, ChannelRepository) as stubs
      </service_tests>

      <entity_conversion_tests>
        Test From/Into implementations:
        - test_create_role_input_to_relationships - verify correct number and structure
        - test_permission_bitmask_parsing - test with single bit, multiple bits, all bits
        - test_permission_to_relation_mapping - verify all 12 permission mappings
        - test_channel_permission_filtering - verify non-channel permissions are filtered
        - test_override_target_user_conversion
        - test_override_target_role_conversion
        - test_permission_override_grant_vs_deny
      </entity_conversion_tests>
    </unit_tests>
  </testing_requirements>

  <integration_points>
    <appstate_updates path="listeners/src/rabbit/consumers/mod.rs or app.rs">
      <content>
        Update AppState struct:
        - Change service field type from Service&lt;AuthzedServerRepository, AuthzedChannelRepository&gt;
        - To: Service&lt;AuthzedServerRepository, AuthzedChannelRepository, AuthzedRoleRepository, AuthzedPermissionOverrideRepository&gt;

        Initialize new repositories:
        - let role_repo = AuthzedRoleRepository::new(authzed_client.clone(), permissions_descriptor.clone());
        - let override_repo = AuthzedPermissionOverrideRepository::new(authzed_client.clone(), permissions_descriptor.clone());
        - let service = Service::new(server_repo, channel_repo, role_repo, override_repo);
      </content>
    </appstate_updates>

    <permissions_descriptor path="listeners/src/app.rs or main.rs">
      <content>
        Ensure BeepPermissions descriptor is initialized and shared:
        - let permissions_descriptor = BeepPermissions::new().descriptor();
        - Pass to repositories that need bitmask parsing
        - Repositories store as Arc&lt;CapabilityDescriptor&gt; for efficient cloning
      </content>
    </permissions_descriptor>

    <common_utilities path="core/src/infrastructure/common/">
      <file name="permissions.rs">
        <content>
          Shared permission utilities:

          - pub fn parse_permission_bitmask(bitmask: u64, descriptor: &amp;CapabilityDescriptor) -> Vec&lt;String&gt;
          - pub fn permission_display_to_server_relation(display_name: &amp;str) -> Option&lt;&amp;'static str&gt;
          - pub fn permission_display_to_channel_relation(display_name: &amp;str, is_grant: bool) -> Option&lt;String&gt;
          - pub fn is_channel_permission(display_name: &amp;str) -> bool

          These can be shared between role and permission_override repositories
        </content>
      </file>
    </common_utilities>

    <module_exports>
      Update module hierarchies:
      - core/src/domain/mod.rs: pub mod role; pub mod permission_override;
      - core/src/infrastructure/mod.rs: pub mod role; pub mod permission_override;
      - listeners/src/rabbit/mod.rs: pub mod role; pub mod permission_override;
    </module_exports>
  </integration_points>

  <key_implementation_notes>
    <permission_bitmask_handling>
      When receiving permissions_bitmask (example: 0x88 = 0x80 | 0x8):
      1. Iterate through BeepPermissions::all_permissions()
      2. For each permission, get its hex value: let hex_value: u64 = permission.into()
      3. Check if bit is set: if bitmask &amp; hex_value != 0
      4. If set, add permission.to_string() to results
      5. Map display name to relation name using lookup table

      Example code:
      ```rust
      let mut permissions = Vec::new();
      for permission in BeepPermissions::all_permissions() {
          let hex_value: u64 = permission.clone().into();
          if bitmask &amp; hex_value != 0 {
              let display_name = permission.to_string();
              if let Some(relation) = permission_to_server_relation(&amp;display_name) {
                  permissions.push(relation.to_string());
              }
          }
      }
      ```
    </permission_bitmask_handling>

    <role_update_semantics>
      UpsertRole with existing role_id should:
      1. Query existing server#*@role:role_id#member relationships (optional, for efficiency)
      2. Delete all existing server permission relations for this role using filtered delete
      3. Create role#server relationship (idempotent, will update if exists)
      4. Create new server#relation@role#member relationships based on new bitmask

      This ensures UPDATE replaces permissions, not merges them.
    </role_update_semantics>

    <permission_override_channel_only>
      Channel permissions only (from beep.zed):
      - send_message (SendMessages = 0x80)
      - view (ViewChannels = 0x40)
      - manage_message (ManageMessages = 0x400)
      - attach_files (AttachFiles = 0x800)
      - manage_webhooks (ManageWebhooks = 0x20)

      When parsing permission_bitmask for channel overrides:
      - ONLY process these 5 permissions
      - Log warning if other bits are set (server-level permissions)
      - Continue processing (don't fail)
    </permission_override_channel_only>

    <override_metadata_storage>
      For DeletePermissionOverride to work:
      1. When creating override, store mapping: override_id -> OverrideMetadata
      2. OverrideMetadata contains: channel_id, permission_bitmask, is_allow, target
      3. On delete, lookup metadata and reconstruct relationships to delete
      4. Use Arc&lt;RwLock&lt;HashMap&lt;String, OverrideMetadata&gt;&gt;&gt; in repository
      5. For production: consider persistent storage (Redis, database)

      Alternative: Store override_id in AuthZed relationship caveat (if supported)
    </override_metadata_storage>

    <error_handling_philosophy>
      - Handlers: Log errors, return Ok(()) to prevent message requeue
      - Services: Propagate errors from repositories to handlers
      - Repositories: Convert AuthZed errors to domain errors with context
      - Never panic in async code
      - Use Result types throughout
      - Idempotent operations where possible (create is upsert, delete is soft)
    </error_handling_philosophy>

    <bulk_operations>
      For efficiency, use bulk operations where possible:
      - UpsertRole: Create multiple relationships in one AuthZed call
      - UpsertPermissionOverride: Create multiple channel overrides in one call
      - DeleteRole: Use filtered delete for batch deletion

      Check authzed_client API for bulk_write or batch methods
    </bulk_operations>
  </key_implementation_notes>

  <file_structure_overview>
    <tree>
      authz/
      ├── core/src/
      │   ├── domain/
      │   │   ├── role/
      │   │   │   ├── mod.rs              (RoleError enum, module exports)
      │   │   │   ├── entities.rs         (CreateRoleInput, DeleteRoleInput, AssignMemberInput, RemoveMemberInput)
      │   │   │   ├── port.rs             (RoleRepository, RoleService traits)
      │   │   │   └── service.rs          (RoleService implementation + comprehensive tests)
      │   │   ├── permission_override/
      │   │   │   ├── mod.rs              (PermissionOverrideError enum)
      │   │   │   ├── entities.rs         (CreatePermissionOverrideInput, DeletePermissionOverrideInput, OverrideTarget)
      │   │   │   ├── port.rs             (PermissionOverrideRepository, PermissionOverrideService traits)
      │   │   │   └── service.rs          (PermissionOverrideService implementation + tests)
      │   │   ├── common/
      │   │   │   └── service.rs          (UPDATED: Service&lt;S, C, R, P&gt; struct)
      │   │   └── mod.rs                  (UPDATED: export role and permission_override modules)
      │   └── infrastructure/
      │       ├── role/
      │       │   └── repository/
      │       │       ├── mod.rs          (export authzed module)
      │       │       └── authzed/
      │       │           ├── mod.rs      (AuthzedRoleRepository implementation)
      │       │           └── entities.rs (Conversion implementations, helper functions)
      │       ├── permission_override/
      │       │   └── repository/
      │       │       ├── mod.rs          (export authzed module)
      │       │       └── authzed/
      │       │           ├── mod.rs      (AuthzedPermissionOverrideRepository with mapping)
      │       │           └── entities.rs (Conversion implementations, channel permission filtering)
      │       ├── common/
      │       │   └── permissions.rs      (NEW: Shared bitmask parsing utilities)
      │       └── mod.rs                  (UPDATED: export new modules)
      └── listeners/src/
          ├── rabbit/
          │   ├── role/
          │   │   └── handler.rs          (4 handlers: upsert_role, delete_role, assign_member, remove_member)
          │   ├── permission_override/
          │   │   └── handler.rs          (2 handlers: upsert_permission_override, delete_permission_override)
          │   ├── consumers/
          │   │   └── mod.rs              (UPDATED: route new protobuf events to handlers, update AppState)
          │   └── mod.rs                  (UPDATED: export new modules)
          └── permissions_translations.rs (EXISTING: reference for permission definitions)
    </tree>
  </file_structure_overview>

  <deliverables>
    <checklist>
      ☐ 1. Role domain module (core/src/domain/role/)
        ☐ a. mod.rs with RoleError enum
        ☐ b. entities.rs with 4 input structs
        ☐ c. port.rs with RoleRepository and RoleService traits
        ☐ d. service.rs with implementation and 8+ unit tests

      ☐ 2. Permission Override domain module (core/src/domain/permission_override/)
        ☐ a. mod.rs with PermissionOverrideError enum
        ☐ b. entities.rs with OverrideTarget enum and input structs
        ☐ c. port.rs with repository and service traits
        ☐ d. service.rs with implementation and tests

      ☐ 3. Role repository (core/src/infrastructure/role/repository/authzed/)
        ☐ a. mod.rs with AuthzedRoleRepository implementation
        ☐ b. entities.rs with conversions and bitmask parsing

      ☐ 4. Permission Override repository (core/src/infrastructure/permission_override/repository/authzed/)
        ☐ a. mod.rs with AuthzedPermissionOverrideRepository and mapping storage
        ☐ b. entities.rs with channel permission filtering

      ☐ 5. Shared utilities (core/src/infrastructure/common/permissions.rs)
        ☐ a. Bitmask parsing functions
        ☐ b. Permission-to-relation mapping functions
        ☐ c. Channel permission validation

      ☐ 6. Role handlers (listeners/src/rabbit/role/handler.rs)
        ☐ a. upsert_role handler
        ☐ b. delete_role handler
        ☐ c. assign_member_to_role handler
        ☐ d. remove_member_from_role handler

      ☐ 7. Permission Override handlers (listeners/src/rabbit/permission_override/handler.rs)
        ☐ a. upsert_permission_override handler
        ☐ b. delete_permission_override handler

      ☐ 8. Integration updates
        ☐ a. Update Service struct in core/src/domain/common/service.rs
        ☐ b. Update AppState in listeners
        ☐ c. Register handlers in RabbitMQ consumer routing
        ☐ d. Initialize new repositories with dependencies

      ☐ 9. Testing
        ☐ a. Unit tests for all service methods (following existing patterns)
        ☐ b. Tests for entity conversions
        ☐ c. Tests for permission bitmask parsing
        ☐ d. Tests for channel permission filtering
    </checklist>
  </deliverables>

  <implementation_order>
    <phases>
      <phase number="1" name="Domain Foundation">
        1. Create role domain (entities, port, mod.rs)
        2. Create permission_override domain (entities, port, mod.rs)
        3. Create shared permissions.rs utilities
        4. Update common/service.rs to add type parameters
      </phase>

      <phase number="2" name="Service Layer">
        5. Implement RoleService in role/service.rs with tests
        6. Implement PermissionOverrideService in permission_override/service.rs with tests
        7. Run tests: cargo test --package authz-core
      </phase>

      <phase number="3" name="Repository Layer">
        8. Implement AuthzedRoleRepository with entities.rs conversions
        9. Implement AuthzedPermissionOverrideRepository with mapping storage
        10. Add repository entity conversion tests
      </phase>

      <phase number="4" name="Handler Layer">
        11. Implement role handlers (4 functions)
        12. Implement permission_override handlers (2 functions)
        13. Update consumer routing to register handlers
        14. Update AppState initialization
      </phase>

      <phase number="5" name="Integration &amp; Testing">
        15. Build full project: cargo build
        16. Run all tests: cargo test
        17. Fix any compilation errors or test failures
        18. Test with sample protobuf messages (manual/integration tests)
      </phase>
    </phases>
  </implementation_order>

  <critical_reminders>
    <reminder priority="high">
      Role permissions create MULTIPLE server relationships - one for EACH permission bit set.
      Example: bitmask 0x88 creates TWO relationships:
      - server:srv#message_sender@role:role#member
      - server:srv#invitation_creator@role:role#member
    </reminder>

    <reminder priority="high">
      Permission overrides are ONLY for channel-level permissions. Filter out server-level permissions.
      Valid: SendMessages, ViewChannels, ManageMessages, AttachFiles, ManageWebhooks
      Invalid (ignore): Administrator, ManageServer, ManageRoles, etc.
    </reminder>

    <reminder priority="high">
      DeletePermissionOverride requires metadata storage because override_id alone is insufficient.
      Implement mapping: override_id -> (channel_id, permission_bitmask, is_allow, target)
    </reminder>

    <reminder priority="medium">
      UpsertRole should DELETE existing permissions before creating new ones (update = replace, not merge)
    </reminder>

    <reminder priority="medium">
      DeleteRole does NOT need to separately delete member assignments - they cascade via filtered_delete
    </reminder>

    <reminder priority="low">
      Follow exact test patterns from server/service.rs - use Arc&lt;Mutex&gt; for mock state tracking
    </reminder>
  </critical_reminders>
</implementation_specification>
